1. 线程相关问题
线程相关的问题一般伴随着CPU占用率异常，常遇到的线程问题：

线程死锁
某线程死循环
阻塞
JVM线程问题常用排查工具：

top
jstack
基本检查步骤如下：

top命令查看进程CPU占用率，记下进程号
top -Hp 进程号 查看线程运行CPU使用情况，观察一下，如果某些线程占用率特别高，是值得关注的，记录下线程号。
printf "%x\n" 线程号，把线程号用16进制打印出来。
jstack 进程号 > jstack.log，把线程状态dump下来，在jstack.log中找到对应线程号的信息，可以看到当前线程执行到哪行代码。
1.1 死锁问题
还没有实战过，基本是在jstack.log中查看一下是否有block的线程，因为据说jstack会自动分析出死锁的线程并提示。

TODO
1.2 死循环
这个比较常见，也最容易发现，通过基本诊断步骤可以精确定位到哪个类，哪个方法在死循环，可以通过如下方法去验证。

验证方法：

重复若干次jstack 进程号 > jstack.log，查看线程状态如果CPU占用最高的那一两个线程反复的执行某一个方法或者某行代码，然后检查一下代码，这样的问题应该很快就可以定位出来。

1.3 Tomcat重启负载过高
之前有一台两个核的机器遇到过这种问题，通过上边的基本步骤排查出来是两个c2线程在编译，cpu 100%,具体的描述可以参考如下三篇文章：

Tomcat重启负载高问题定位
关于Java启动性能的一个解决方法
又碰Java启动性能问题
2. 内存
这个内存使用情况比较复杂的时候应该比较难搞，尤其是线上的，日常环境的可以直接用visualvm连上去看。一般流程是dump下堆，然后用MAT分析。

TODO
3. MAVEN相关
3.1 依赖冲突
MAVEN依赖冲突比较常见，常见的是依赖了不同版本的jar包，导致类加载的时候还刚好加载进来某个不想要的包，这种情况在项目中特别的多，往往是大量的依赖第三方的包，然后传递依赖其他的包进来，如果没有仔细的排除，时常会导致依赖冲突发生。可以参考如下文章：

Maven依赖的传递性
Maven类包冲突终极解决小技若干
按上面文章里边排依赖肯定是可以的，但是太慢了，而且依赖树不好看，排除起来也是挺累的，如果需要排除的依赖比较少，使用IDEA的图形工具排是非常方便的，也有缺点就是IDEA渲染太慢。

3.2 实际依赖的版本和本地版本不一致
这情况在查其他问题的时候遇到，预发上抛了一个异常出来，然后根据堆栈，在开发机上定位到一个三方库里边的某行代码，但是却发现此处完全不可能抛出这样的异常，最后发现原来我们的日常、预发、线上的中间件包实际上是用的pandora里边的，跟我们自己本地工程依赖的包不一样的，可以参考:
Pandora Container 轻量级隔离容器。

查看线上运行的程序加载的jar包版本参考下边文章,pmap命令特别好用:
tddl版本冲突解决处理

4.其他
4.1 sls日志相关
平时在使用simplelog的时候出现过如下两个问题：

sls日志采集问题

有时候会遇到在服务端上明明有日志，但是在sls控制台就是查不到。这个问题跟打印的日志和配置的正则表达式可能都有关系。

sls会通过Logtail收集日志，由于Java程序的一条日志有可能会有多行，所以Logtail一般通过正则表达式去匹配行首来区分每条日志。sls的日志模型是k-v结构的，因此要提取出一条日志的key和value部分，也需要正则表达式来匹配。简而言之，会有两条正则，一个对日志分条，一个提取值。

所以遇到上述问题，可以查看/usr/local/ilogtail/ilogtail.LOG日志中是否有对应信息，如果有解决方法如下是：打印日志格式一致，与正则匹配。

sls分区调整问题

sls中为了提高日志读写吞吐量，会增加日志的分区(Shard)，所以在通过api拉取sls日志的时候，会遇到原来的读写分区调整成为了只读分区，读取不到新数据的问题。